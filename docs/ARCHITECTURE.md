# Архитектура «БАЗЗЕР» (v2)

---

## 1. Общая схема
```
┌──────────────┐        ┌──────────────┐        ┌───────────────┐
│ Telegram API │◄──────►│   Aiogram    │◄──────►│ Handlers      │
└──────────────┘        └──────────────┘        └──────┬────────┘
                                                       │
                                               ┌───────▼────────┐
                                               │ Services       │
                                               │ (game_service, │
                                               │  game_state)   │
                                               └───────┬────────┘
                                                       │
                                           ┌───────────▼───────────┐
                                           │ SQLAlchemy ORM / DB   │
                                           │ (async engine SQLite) │
                                           └───────────────────────┘
```

- <b>handlers.commands</b> — `/start`, `/help`, обработка текстового ввода названия.
- <b>handlers.callbacks</b> — весь интерактив: регистрация, «БАЗЗЕР», админ-панель.
- <b>services.game_service</b> — бизнес-логика (игроки, команды, игра, схема очков, очередь).
- <b>services.game_state</b> — in-memory очередь per `game_id` (используется только во время вопроса).
- <b>models</b> — Player ↔ Team (через TeamMember) + Game + GameParticipant (счёт).

---

## 2. Модель данных
- `players` — все пользователи, когда-либо написавшие боту (Telegram ID, username, имя).
- `teams` — уникальные названия команд.
- `team_members` — связь игрок ↔ команда (один игрок = одна команда).
- `games` — игра, запущенная администратором (`status` ∈ {`idle`, `running`, `question`, `finished`}).
- `game_participants` — счёт команды в рамках игры.

В одной базе хранится история игр; при запуске новой игры добавляется запись в `games`, предыдущая (если была) переводится в `finished`.

---

## 3. Состояния игры
- `idle` — создана, но ещё не запущена.
- `running` — игра идёт, вопрос не активен.
- `question` — открыт вопрос, игроки могут жать «БАЗЗЕР» (очередь активна).
- `finished` — игра завершена, очередь очищена, очки доступны в таблице.

Переходы:
1. `/start` админа → `idle` (создаётся запись).
2. Кнопка «🚀 Запустить игру» → `running` + рассылка «готовьтесь».
3. «❓ Запустить вопрос» → `question` + рассылка «БАЗЗЕР».
4. «✅ Верно» → `running` (очередь очищена, балл начислен).
5. «❌ Неверно» → остаётся `question`, пока очередь не опустеет; затем `running`.
6. «🛑 Завершить игру» → `finished`.

---

## 4. Очередь
- Хранится в `STATE[game_id]`, структура `Queue[int]` (team_id).
- Доступ защищён `asyncio.Lock` — все операции (`press_buzzer`, `pop_queue`, `current_queue`).
- На старте вопроса `reset_round(game_id)` очищает очередь.
- После «Верно» вызывается `finish_question`, что также сбрасывает очередь.

---

## 5. Очки
- `award_score` добавляет баллы записи `GameParticipant`.
- Таблица строится через `get_scores` (JOIN `game_participants` + `teams`).
- При добавлении новых команд в процессе игры `ensure_participants` создаёт записи для них.

---

## 6. Изоляция логики
- <b>game_service</b> — не использует Aiogram; удобно покрывать тестами.
- <b>callbacks</b> — максимум «клей» между сервисами и Telegram API (рассылка сообщений, построение клавиатур).
- <b>registration_state</b> — минимальное состояние для ожидания названия команды (вместо FSM).

---

## 7. Расширение
- <b>Несколько игр</b>: текущая модель предполагает одну активную игру. Для мультиигрового режима добавьте поле «channel» или «context» в `Game` и прокиньте его в `STATE`.
- <b>Другие очки</b>: измените `points` в `award_score` или передавайте разные значения в зависимости от вопроса.
- <b>Персистентная очередь</b>: замените `game_state` на Redis, сохранив API `get_state/reset_round`.

---

## 8. Потенциальные доработки
- Выход из команды / смена названия.
- Выбор количества баллов через отдельные кнопки.
- Интеграция с внешними мессенджерами (Slack/Discord) через дополнительный слой в `callbacks`.

Архитектура сохраняет чистое разделение: данные ↔ сервисы ↔ Telegram. Это упрощает тестирование и дальнейшее развитие.
